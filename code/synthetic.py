from follow_network import FollowNetwork
from random_graph import RandomDirectedGraph
from typing import Set, List, Tuple
from user import User


def validate_solution(all_influencers: Set[User], num_users: int) -> Tuple[bool, bool]:
    """
    Certify that the set of influencers is the optimal solution
    :param all_influencers: a set of Users representing the set of influencers generated by the algorithm
    :param num_users: total number of users
    :return: (True, True) if the input is optimal, and False if otherwise
    """

    all_influencers = set(all_influencers)

    visited_global = set()
    visited_local = {}

    valid = True

    def dfs(node, start):
        """
        Perform the dfs starting from start
        :param node:
        :param start:
        :return:
        """
        nonlocal valid
        if not valid:
            return
        if node in all_influencers and node != start:
            valid = False
            # print("invalid!!!")
            return
        if node in visited_local[start]:
            return
        visited_local[start].add(node)
        visited_global.add(node)

        for next_node in node.follower:
            dfs(next_node, start)

    for influencer in all_influencers:
        visited_local[influencer] = set()
        dfs(influencer, influencer)

    return valid, (num_users == len(visited_global))

if __name__ == "__main__":
    # synthetic datasets
    result_file_path = "erdos_renyi_results.csv"
    parameter_sets = [
                         (i, j) for i in (10, 20, 50, 100, 200, 500)
                         for j in (1E-4, 1E-3, 2E-3, 5E-3, 0.01, 0.02, 0.05, 0.1)
                     ] + [
                         (i, j) for i in (1000, 2000, 5000, 10000)
                         for j in (1E-6, 1E-5, 1E-4, 2E-4, 5E-4, 1E-3)
                     ]

    n_folds = 100

    import sys

    sys.setrecursionlimit(1000000000)

    with open(result_file_path, "a") as file:  # MUST USE append mode!
        file.write("n_influencers,valid_1,valid_2,n,p,num_edges,mean_degrees,std_num_followers,std_num_followings\n")
        for (idx, (n, p)) in enumerate(parameter_sets):
            for fold in range(n_folds):
                print(f"param {idx}, fold {fold}: {n}, {p}" + " " * 50, end='\r')
                graph_1 = RandomDirectedGraph(n, p)
                graph_1.generate_erdos_renyi_graph()
                s = FollowNetwork([i for i in graph_1.erdos_graph.values()])
                influencers = set(s.solve())
                valid_1, valid_2 = [int(x) for x in validate_solution([graph_1.erdos_graph[i] for i in influencers], n)]
                num_edges, mean_degree, std_num_follower, std_num_following = graph_1.num_edges(), graph_1.mean_degree(), graph_1.std_num_follower(), graph_1.std_num_following()
                file.write(
                    f"{len(influencers)},{valid_1},{valid_2},{n},{p},{num_edges},{mean_degree},{std_num_follower},{std_num_following}\n",
                )
                file.flush()

    import pandas as pd

    erdos_res_df = pd.read_csv(result_file_path)

    def get_summary_res(df):
        return pd.Series(
            {"n_sample": len(df),
             "n_influencers_mean": df['n_influencers'].mean(),
             "n_influencers_std": df['n_influencers'].std(),
             "pct_valid": (df['valid_1'] * df['valid_2']).sum() / len(df),
             "num_edges_mean": df["num_edges"].mean(),
             "mean_degrees_mean": df["mean_degrees"].mean(),
             }
        )

    erdos_grouped_res_df = erdos_res_df.groupby(
        ['n', 'p']
    ).apply(
        get_summary_res
    ).reset_index(['n', 'p'])

    erdos_grouped_res_df["n_times_p"] = erdos_grouped_res_df["n"] * erdos_grouped_res_df["p"]

    erdos_grouped_res_df["pct_influencers_mean"] = erdos_grouped_res_df["n_influencers_mean"] / erdos_grouped_res_df["n"]

    erdos_grouped_res_df.to_csv("erdos_result_summary.csv")
